{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"blockdownload API Documentation","text":""},{"location":"#bdown.check","title":"<code>check</code>","text":""},{"location":"#bdown.check.Check","title":"<code>Check</code>","text":"<p>check a download</p> Source code in <code>bdown/check.py</code> <pre><code>class Check:\n    \"\"\"\n    check a download\n    \"\"\"\n\n    def __init__(self, args):\n        self.args = args\n        self.size1 = os.path.getsize(args.file1)\n        self.size2 = os.path.getsize(args.file2)\n        self.blocksize = args.blocksize\n        self.max_mb = min(self.size1, self.size2) // (1024 * 1024) - 1\n        self.offsets = self.calculate_offsets()\n        self.status_counter = Counter()\n        self.quiet = len(self.offsets) &gt; 20\n\n    def calculate_offsets(self):\n        start = self.args.start\n        step = self.args.step\n        count = self.args.count\n        factor = self.args.factor\n        mode = self.args.mode\n\n        if mode in (\"linear\", \"log\"):\n            if step is None:\n                sys.exit(\"Error: --step is required for linear/log mode\")\n            i = 0\n            offsets = []\n            while True:\n                if mode == \"linear\":\n                    mb = start + int(i * step)\n                else:\n                    base = factor if factor is not None else step\n                    mb = start + int(round(base**i))\n                if count is not None and i &gt;= count:\n                    break\n                if mb &gt; self.max_mb:\n                    break\n                offsets.append(mb)\n                i += 1\n            return [mb * 1024 * 1024 for mb in offsets]\n\n        elif mode == \"full\":\n            return [mb * 1024 * 1024 for mb in range(0, self.max_mb + 1)]\n\n        else:\n            sys.exit(f\"Unsupported mode: {mode}\")\n\n    def is_zero_block(self, data):\n        return all(b == 0 for b in data)\n\n    def read_block(self, f, offset):\n        f.seek(offset)\n        return f.read(self.blocksize)\n\n    def status(self, index, symbol, offset_mb, message):\n        self.status_counter[symbol] += 1\n        if not self.quiet:\n            print(f\"[{index:3}] {offset_mb:7,} MB  {symbol}  {message}\")\n\n    def run(self):\n        with open(self.args.file1, \"rb\") as f1, open(self.args.file2, \"rb\") as f2:\n            iterator = enumerate(self.offsets)\n            if self.quiet and tqdm:\n                iterator = tqdm(iterator, total=len(self.offsets))\n            for i, offset in iterator:\n                offset_mb = offset // (1024 * 1024)\n                b1 = self.read_block(f1, offset)\n                b2 = self.read_block(f2, offset)\n\n                if (\n                    not b1\n                    or not b2\n                    or len(b1) &lt; self.blocksize\n                    or len(b2) &lt; self.blocksize\n                ):\n                    self.status(i, FAIL, offset_mb, \"could not read full block\")\n                    continue\n\n                zero1 = self.is_zero_block(b1)\n                zero2 = self.is_zero_block(b2)\n                if zero1 or zero2:\n                    who = []\n                    if zero1:\n                        who.append(\"file1\")\n                    if zero2:\n                        who.append(\"file2\")\n                    self.status(i, WARN, offset_mb, f\"zero block in {', '.join(who)}\")\n                    continue\n\n                md5_1 = hashlib.md5(b1).hexdigest()\n                md5_2 = hashlib.md5(b2).hexdigest()\n                if md5_1 == md5_2:\n                    self.status(i, CHECK, offset_mb, \"MD5 match\")\n                else:\n                    self.status(i, FAIL, offset_mb, \"MD5 mismatch\")\n                    if not self.quiet:\n                        print(f\"           file1: {md5_1}\")\n                        print(f\"           file2: {md5_2}\")\n\n        print()\n        print(\"Summary:\", dict(self.status_counter))\n</code></pre>"},{"location":"#bdown.download","title":"<code>download</code>","text":"<p>Created on 2025-05-05</p> <p>@author: wf</p>"},{"location":"#bdown.download.Block","title":"<code>Block</code>","text":"<p>A single download block.</p> Source code in <code>bdown/download.py</code> <pre><code>@lod_storable\nclass Block:\n    \"\"\"\n    A single download block.\n    \"\"\"\n\n    block: int\n    path: str\n    offset: int\n    md5: str = None  # full md5 hash\n    md5_head: str = None  # hash of first chunk\n\n    def calc_md5(self, base_path: str, chunk_size: int = 8192, chunk_limit: int = None) -&gt; str:\n        \"\"\"\n        Calculate the MD5 checksum of this block's file.\n\n        Args:\n            base_path: Directory where the block's relative path is located.\n            chunk_size: Bytes per read operation (default: 8192).\n            chunk_limit: Maximum number of chunks to read (e.g. 1 for md5_head).\n\n        Returns:\n            str: The MD5 hexadecimal digest.\n        \"\"\"\n        full_path = os.path.join(base_path, self.path)\n        hash_md5 = hashlib.md5()\n        index = 0\n\n        with open(full_path, \"rb\") as f:\n            for chunk in iter(lambda: f.read(chunk_size), b\"\"):\n                hash_md5.update(chunk)\n                index += 1\n                if chunk_limit is not None and index &gt;= chunk_limit:\n                    break\n\n        return hash_md5.hexdigest()\n\n\n    @classmethod\n    def ofResponse(\n        cls,\n        block_index: int,\n        offset: int,\n        chunk_size: int,\n        target_path: str,\n        response: requests.Response,\n        progress_bar=None,\n    ) -&gt; \"Block\":\n        \"\"\"\n        Create a Block from a download HTTP response.\n\n        Args:\n            block_index: Index of the block.\n            offset: Byte offset within the full file.\n            target_path: Path to the .part file to write.\n            response: The HTTP response streaming the content.\n            progress_bar: optional progress_bar for reporting download progress.\n\n        Returns:\n            Block: The constructed block with calculated md5.\n        \"\"\"\n        hash_md5 = hashlib.md5()\n        hash_head = hashlib.md5()\n        first = True\n        block_path=os.path.basename(target_path)\n        if progress_bar:\n            progress_bar.set_description(block_path)\n        with open(target_path, \"wb\") as f:\n            for chunk in response.iter_content(chunk_size=chunk_size):\n                f.write(chunk)\n                hash_md5.update(chunk)\n                if first:\n                    hash_head.update(chunk)\n                    first = False\n                if progress_bar:\n                    progress_bar.update(len(chunk))\n        block = cls(\n            block=block_index,\n            path=block_path,\n            offset=offset,\n            md5=hash_md5.hexdigest(),\n            md5_head=hash_head.hexdigest(),\n        )\n        return block\n</code></pre>"},{"location":"#bdown.download.Block.calc_md5","title":"<code>calc_md5(base_path, chunk_size=8192, chunk_limit=None)</code>","text":"<p>Calculate the MD5 checksum of this block's file.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>str</code> <p>Directory where the block's relative path is located.</p> required <code>chunk_size</code> <code>int</code> <p>Bytes per read operation (default: 8192).</p> <code>8192</code> <code>chunk_limit</code> <code>int</code> <p>Maximum number of chunks to read (e.g. 1 for md5_head).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The MD5 hexadecimal digest.</p> Source code in <code>bdown/download.py</code> <pre><code>def calc_md5(self, base_path: str, chunk_size: int = 8192, chunk_limit: int = None) -&gt; str:\n    \"\"\"\n    Calculate the MD5 checksum of this block's file.\n\n    Args:\n        base_path: Directory where the block's relative path is located.\n        chunk_size: Bytes per read operation (default: 8192).\n        chunk_limit: Maximum number of chunks to read (e.g. 1 for md5_head).\n\n    Returns:\n        str: The MD5 hexadecimal digest.\n    \"\"\"\n    full_path = os.path.join(base_path, self.path)\n    hash_md5 = hashlib.md5()\n    index = 0\n\n    with open(full_path, \"rb\") as f:\n        for chunk in iter(lambda: f.read(chunk_size), b\"\"):\n            hash_md5.update(chunk)\n            index += 1\n            if chunk_limit is not None and index &gt;= chunk_limit:\n                break\n\n    return hash_md5.hexdigest()\n</code></pre>"},{"location":"#bdown.download.Block.ofResponse","title":"<code>ofResponse(block_index, offset, chunk_size, target_path, response, progress_bar=None)</code>  <code>classmethod</code>","text":"<p>Create a Block from a download HTTP response.</p> <p>Parameters:</p> Name Type Description Default <code>block_index</code> <code>int</code> <p>Index of the block.</p> required <code>offset</code> <code>int</code> <p>Byte offset within the full file.</p> required <code>target_path</code> <code>str</code> <p>Path to the .part file to write.</p> required <code>response</code> <code>Response</code> <p>The HTTP response streaming the content.</p> required <code>progress_bar</code> <p>optional progress_bar for reporting download progress.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Block</code> <code>Block</code> <p>The constructed block with calculated md5.</p> Source code in <code>bdown/download.py</code> <pre><code>@classmethod\ndef ofResponse(\n    cls,\n    block_index: int,\n    offset: int,\n    chunk_size: int,\n    target_path: str,\n    response: requests.Response,\n    progress_bar=None,\n) -&gt; \"Block\":\n    \"\"\"\n    Create a Block from a download HTTP response.\n\n    Args:\n        block_index: Index of the block.\n        offset: Byte offset within the full file.\n        target_path: Path to the .part file to write.\n        response: The HTTP response streaming the content.\n        progress_bar: optional progress_bar for reporting download progress.\n\n    Returns:\n        Block: The constructed block with calculated md5.\n    \"\"\"\n    hash_md5 = hashlib.md5()\n    hash_head = hashlib.md5()\n    first = True\n    block_path=os.path.basename(target_path)\n    if progress_bar:\n        progress_bar.set_description(block_path)\n    with open(target_path, \"wb\") as f:\n        for chunk in response.iter_content(chunk_size=chunk_size):\n            f.write(chunk)\n            hash_md5.update(chunk)\n            if first:\n                hash_head.update(chunk)\n                first = False\n            if progress_bar:\n                progress_bar.update(len(chunk))\n    block = cls(\n        block=block_index,\n        path=block_path,\n        offset=offset,\n        md5=hash_md5.hexdigest(),\n        md5_head=hash_head.hexdigest(),\n    )\n    return block\n</code></pre>"},{"location":"#bdown.download.BlockDownload","title":"<code>BlockDownload</code>","text":"Source code in <code>bdown/download.py</code> <pre><code>@lod_storable\nclass BlockDownload:\n    name: str\n    url: str\n    blocksize: int\n    chunk_size: int = 8192  # size of a response chunk\n    size: int = None\n    unit: str = \"MB\"  # KB, MB, or GB\n    md5: str = \"\"\n    blocks: List[Block] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.unit_multipliers = {\n            \"KB\": 1024,\n            \"MB\": 1024 * 1024,\n            \"GB\": 1024 * 1024 * 1024,\n        }\n        if self.unit not in self.unit_multipliers:\n            raise ValueError(f\"Unsupported unit: {self.unit} - must be KB, MB or GB\")\n        self.lock = Lock()\n        self.active_blocks = set()\n        self.progress_lock = Lock()\n\n    @property\n    def blocksize_bytes(self) -&gt; int:\n        return self.blocksize * self.unit_multipliers[self.unit]\n\n    def block_range_str(self) -&gt; str:\n        if not self.active_blocks:\n            range_str=\"\u2205\"\n        else:\n            min_block = min(self.active_blocks)\n            max_block = max(self.active_blocks)\n            range_str=f\"{min_block}\" if min_block == max_block else f\"{min_block}\u2013{max_block}\"\n        return range_str\n\n    @classmethod\n    def ofYamlPath(cls, yaml_path: str):\n        block_download = cls.load_from_yaml_file(yaml_path)\n        block_download.yaml_path = yaml_path\n        return block_download\n\n    def save(self):\n        if hasattr(self, \"yaml_path\") and self.yaml_path:\n            self.save_to_yaml_file(self.yaml_path)\n\n    def _get_remote_file_size(self) -&gt; int:\n        response = requests.head(self.url, allow_redirects=True)\n        response.raise_for_status()\n        return int(response.headers.get(\"Content-Length\", 0))\n\n    def block_ranges(\n        self, from_block: int, to_block: int\n    ) -&gt; List[Tuple[int, int, int]]:\n        \"\"\"\n        Generate a list of (index, start, end) tuples for the given block range.\n\n        Args:\n            from_block: Index of first block.\n            to_block: Index of last block (inclusive).\n\n        Returns:\n            List of (index, start, end).\n        \"\"\"\n        if self.size is None:\n            self.size = self._get_remote_file_size()\n        result = []\n        block_size = self.blocksize_bytes\n        for index in range(from_block, to_block + 1):\n            start = index * block_size\n            end = min(start + block_size - 1, self.size - 1)\n            result.append((index, start, end))\n        return result\n\n    def compute_total_bytes(\n        self, from_block: int, to_block: int=None\n    ) -&gt; Tuple[int, int, int]:\n        \"\"\"\n        Compute the total number of bytes to download for a block range.\n\n        Args:\n            from_block: First block index.\n            to_block: Last block index (inclusive), or None for all blocks.\n\n        Returns:\n            Tuple of (from_block, to_block, total_bytes).\n        \"\"\"\n        if self.size is None:\n            self.size = self._get_remote_file_size()\n        total_blocks = (self.size + self.blocksize_bytes - 1) // self.blocksize_bytes\n        if to_block is None or to_block &gt;= total_blocks:\n            to_block = total_blocks - 1\n\n        total_bytes = 0\n        for _, start, end in self.block_ranges(from_block, to_block):\n            total_bytes += end - start + 1\n\n        return from_block, to_block, total_bytes\n\n    def download(\n        self,\n        target: str,\n        from_block: int = 0,\n        to_block: int = None,\n        boost: int = 1,\n        progress_bar=None,\n    ):\n        \"\"\"\n        Download selected blocks and save them to individual .part files.\n\n        Args:\n            target: Directory to store .part files.\n            from_block: Index of the first block to download.\n            to_block: Index of the last block (inclusive), or None to download until end.\n            boost: Number of parallel download threads to use (default: 1 = serial).\n            progress_bar: Optional tqdm-compatible progress bar for visual feedback.\n        \"\"\"\n        if self.size is None:\n            self.size = self._get_remote_file_size()\n        os.makedirs(target, exist_ok=True)\n\n        if to_block is None:\n            total_blocks = (self.size + self.blocksize_bytes - 1) // self.blocksize_bytes\n            to_block = total_blocks - 1\n\n        block_specs = self.block_ranges(from_block, to_block)\n\n        if boost == 1:\n            for index, start, end in block_specs:\n                self._download_block(index, start, end, target, progress_bar)\n        else:\n            with ThreadPoolExecutor(max_workers=boost) as executor:\n                for index, start, end in block_specs:\n                    executor.submit(self._download_block, index, start, end, target, progress_bar)\n\n\n    def update_progress(self,progress_bar,index:int):\n        with self.progress_lock:\n            if index&gt;0:\n                self.active_blocks.add(index)\n            else:\n                self.active_blocks.remove(-index)\n            if progress_bar:\n                progress_bar.set_description(f\"Blocks {self.block_range_str()}\")\n\n    def _download_block(self, index: int, start: int, end: int, target: str, progress_bar):\n        part_name = f\"{self.name}-{index:04d}.part\"\n        part_file = os.path.join(target, part_name)\n\n        if index &lt; len(self.blocks):\n            existing = self.blocks[index]\n            if os.path.exists(part_file) and existing.md5_head:\n                actual_head = existing.calc_md5(\n                    base_path=target,\n                    chunk_size=self.chunk_size,\n                    chunk_limit=1\n                )\n                if actual_head == existing.md5_head:\n                    if progress_bar:\n                        progress_bar.set_description(part_name)\n                        progress_bar.update(end - start + 1)\n                    return\n\n        self.update_progress(progress_bar, index+1)\n        headers = {\"Range\": f\"bytes={start}-{end}\"}\n        response = requests.get(self.url, headers=headers, stream=True)\n        if response.status_code not in (200, 206):\n            raise Exception(f\"HTTP {response.status_code}: {response.text}\")\n\n        block = Block.ofResponse(\n            block_index=index,\n            offset=start,\n            chunk_size=self.chunk_size,\n            target_path=part_file,\n            response=response,\n            progress_bar=progress_bar,\n        )\n\n        with self.lock:\n            if index &lt; len(self.blocks):\n                self.blocks[index] = block\n            else:\n                self.blocks.append(block)\n            self.save()\n        self.update_progress(progress_bar, -(index+1))\n\n    def get_progress_bar(self, from_block: int, to_block: int):\n        _, _, total_bytes = self.compute_total_bytes(from_block, to_block)\n        progress_bar = tqdm(total=total_bytes, unit=\"B\", unit_scale=True)\n        return progress_bar\n</code></pre>"},{"location":"#bdown.download.BlockDownload.block_ranges","title":"<code>block_ranges(from_block, to_block)</code>","text":"<p>Generate a list of (index, start, end) tuples for the given block range.</p> <p>Parameters:</p> Name Type Description Default <code>from_block</code> <code>int</code> <p>Index of first block.</p> required <code>to_block</code> <code>int</code> <p>Index of last block (inclusive).</p> required <p>Returns:</p> Type Description <code>List[Tuple[int, int, int]]</code> <p>List of (index, start, end).</p> Source code in <code>bdown/download.py</code> <pre><code>def block_ranges(\n    self, from_block: int, to_block: int\n) -&gt; List[Tuple[int, int, int]]:\n    \"\"\"\n    Generate a list of (index, start, end) tuples for the given block range.\n\n    Args:\n        from_block: Index of first block.\n        to_block: Index of last block (inclusive).\n\n    Returns:\n        List of (index, start, end).\n    \"\"\"\n    if self.size is None:\n        self.size = self._get_remote_file_size()\n    result = []\n    block_size = self.blocksize_bytes\n    for index in range(from_block, to_block + 1):\n        start = index * block_size\n        end = min(start + block_size - 1, self.size - 1)\n        result.append((index, start, end))\n    return result\n</code></pre>"},{"location":"#bdown.download.BlockDownload.compute_total_bytes","title":"<code>compute_total_bytes(from_block, to_block=None)</code>","text":"<p>Compute the total number of bytes to download for a block range.</p> <p>Parameters:</p> Name Type Description Default <code>from_block</code> <code>int</code> <p>First block index.</p> required <code>to_block</code> <code>int</code> <p>Last block index (inclusive), or None for all blocks.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[int, int, int]</code> <p>Tuple of (from_block, to_block, total_bytes).</p> Source code in <code>bdown/download.py</code> <pre><code>def compute_total_bytes(\n    self, from_block: int, to_block: int=None\n) -&gt; Tuple[int, int, int]:\n    \"\"\"\n    Compute the total number of bytes to download for a block range.\n\n    Args:\n        from_block: First block index.\n        to_block: Last block index (inclusive), or None for all blocks.\n\n    Returns:\n        Tuple of (from_block, to_block, total_bytes).\n    \"\"\"\n    if self.size is None:\n        self.size = self._get_remote_file_size()\n    total_blocks = (self.size + self.blocksize_bytes - 1) // self.blocksize_bytes\n    if to_block is None or to_block &gt;= total_blocks:\n        to_block = total_blocks - 1\n\n    total_bytes = 0\n    for _, start, end in self.block_ranges(from_block, to_block):\n        total_bytes += end - start + 1\n\n    return from_block, to_block, total_bytes\n</code></pre>"},{"location":"#bdown.download.BlockDownload.download","title":"<code>download(target, from_block=0, to_block=None, boost=1, progress_bar=None)</code>","text":"<p>Download selected blocks and save them to individual .part files.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Directory to store .part files.</p> required <code>from_block</code> <code>int</code> <p>Index of the first block to download.</p> <code>0</code> <code>to_block</code> <code>int</code> <p>Index of the last block (inclusive), or None to download until end.</p> <code>None</code> <code>boost</code> <code>int</code> <p>Number of parallel download threads to use (default: 1 = serial).</p> <code>1</code> <code>progress_bar</code> <p>Optional tqdm-compatible progress bar for visual feedback.</p> <code>None</code> Source code in <code>bdown/download.py</code> <pre><code>def download(\n    self,\n    target: str,\n    from_block: int = 0,\n    to_block: int = None,\n    boost: int = 1,\n    progress_bar=None,\n):\n    \"\"\"\n    Download selected blocks and save them to individual .part files.\n\n    Args:\n        target: Directory to store .part files.\n        from_block: Index of the first block to download.\n        to_block: Index of the last block (inclusive), or None to download until end.\n        boost: Number of parallel download threads to use (default: 1 = serial).\n        progress_bar: Optional tqdm-compatible progress bar for visual feedback.\n    \"\"\"\n    if self.size is None:\n        self.size = self._get_remote_file_size()\n    os.makedirs(target, exist_ok=True)\n\n    if to_block is None:\n        total_blocks = (self.size + self.blocksize_bytes - 1) // self.blocksize_bytes\n        to_block = total_blocks - 1\n\n    block_specs = self.block_ranges(from_block, to_block)\n\n    if boost == 1:\n        for index, start, end in block_specs:\n            self._download_block(index, start, end, target, progress_bar)\n    else:\n        with ThreadPoolExecutor(max_workers=boost) as executor:\n            for index, start, end in block_specs:\n                executor.submit(self._download_block, index, start, end, target, progress_bar)\n</code></pre>"},{"location":"#bdown.download_cmd","title":"<code>download_cmd</code>","text":"<p>Command-line interface for BlockDownload</p> <p>Created on 2025-05-05</p> <p>@author: wf</p>"}]}